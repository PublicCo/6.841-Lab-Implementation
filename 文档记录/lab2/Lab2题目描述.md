### 介绍

在这个实验中，你将构建一个键/值服务器，确保每个操作即使在网络故障的情况下也能精确地执行一次，并且这些操作是线性化的。在后续的实验中，我们将复制一个这样的服务器来处理服务器崩溃的情况。

客户端可以向键/值服务器发送三种不同的 RPC 请求：`Put(key, value)`，`Append(key, arg)` 和 `Get(key)`。服务器维护一个键/值对的内存映射（map）。键和值都是字符串。`Put(key, value)` 为映射中的特定键安装或替换值，`Append(key, arg)` 向键的值追加 `arg` 并返回旧值，而 `Get(key)` 获取键的当前值。对于不存在的键，`Get` 应返回一个空字符串。对于不存在的键，`Append` 应该像现有值是零长度字符串一样操作。每个客户端通过 `Clerk` 与服务器通信，使用 `Put/Append/Get` 方法。`Clerk` 管理与服务器的 RPC 交互。

你的服务器必须确保对 `Clerk` 的 `Get/Put/Append` 方法的调用是线性化的。如果客户端请求不是并发的，那么每个客户端的 `Get/Put/Append` 调用应该观察到状态的修改，这些修改是由之前的一系列调用隐含的。对于并发调用，返回值和最终状态必须与操作按某种顺序逐个执行的情况相同。当调用在时间上重叠时，它们是并发的。例如，如果客户端 X 调用了 `Clerk.Put()`，并且客户端 Y 调用了 `Clerk.Append()`，然后客户端 X 的调用返回，则一个调用必须观察到在调用开始之前已经完成的所有调用的效果。

线性化对于应用程序是方便的，因为它是一个单一服务器按顺序处理请求时所看到的行为。例如，如果一个客户端从服务器收到更新请求的成功响应，那么随后从其他客户端启动的读取操作将保证看到该更新的效果。对于一个单一服务器，提供线性化相对来说是很容易的。

## 开始

把题目的操作抄一遍就行

### 键/值服务器 - 无网络故障的情况下（简单）

你的第一个任务是实现一个在没有丢失消息的情况下工作的解决方案。

你需要在 `client.go` 中的 `Clerk` 的 `Put/Append/Get` 方法中添加发送 RPC 的代码，并在 `server.go` 中实现 `Put()`、`Append()` 和 `Get()` RPC 处理程序。

当你通过测试套件中的前两个测试时（“一个客户端”和“多个客户端”），就完成了这个任务。

**提示**: 使用 `go test -race` 检查你的代码是否没有数据竞争。

------

### 键/值服务器 - 处理丢失的消息（简单）

现在你需要修改你的解决方案，以便在面对丢失消息（例如，RPC 请求和 RPC 回复）的情况下继续工作。如果丢失了一个消息，那么客户端的 `ck.server.Call()` 将返回 `false`（更准确地说，`Call()` 会等待一条回复消息，直到超时间隔过去，如果在这段时间内没有收到回复，就返回 `false`）。你会遇到的一个问题是，一个 `Clerk` 可能需要多次发送一个 RPC，直到成功。每次对 `Clerk.Put()` 或 `Clerk.Append()` 的调用应该只导致一次执行，所以你需要确保重发不会导致服务器执行请求两次。

**任务**: 在 `Clerk` 中添加代码以在没有收到回复时进行重试，并在 `server.go` 中添加代码以在需要时过滤重复操作。这些注释包括有关重复检测的指导。

------

**提示**:

- **提示 1**: 你需要唯一地标识客户端操作，以确保键/值服务器每次只执行一个操作。
- **提示 2**: 你需要仔细考虑服务器必须为处理重复的 `Get()`、`Put()` 和 `Append()` 请求（如果有的话）维护什么状态。
- **提示 3**: 你的重复检测方案应该能够快速释放服务器内存，例如，通过让每个 RPC 暗示客户端已经看到了其先前 RPC 的回复。可以假设客户端一次只会调用一个 `Clerk`。