## Lab 3A

第一个任务是实现一个leader选举算法。我们先首先明确这个算法怎么做的。首先是状态图

![image-20240904131124416](C:\Users\leon\AppData\Roaming\Typora\typora-user-images\image-20240904131124416.png)

* 在刚开始（或者最后一个RPC发送且leader下线后），每个follower会被分配随机长度的等待实现准备选举。到了自己的指定时间后，这个follower就会发起一次选举请求：让任期号加一，向其他所有的follower发送请求投票的RPC
  * 如果candidate在选举过程中得到了leader的append entry心跳，会停止选举重新成为follower
  * 如果未过半，选举失败，candidate会等待随机时长再次选举
  * 如果过半，它就是新leader了。
  * 选举要求：candidate最后一条Log的版本比follower新，或者相同版本，但是candidate的log长度大于等于follower
* 如果系统中存在两个leader，（比如某个leader突然挂了，集群选了新leader，但是这个leader又复活了），那么当旧leader收到一个新版本的rpc后会自动关闭自己的心跳传输并变成follower，且开始纠错log

###  选举过程

对于一个 follower，当开始选举时，

1. **首先增大自己当前的 term**，
2. 然后切换到 candidate 状态，
3. 然后选举自己作为 leader，同时并发地向集群其他节点发送 RequestVote RPC，
4. 然后它将处于 candidate 状态，直到发生以下三种情况之一，下文会分别讨论：
   1. 该 follower 赢得此次选举，成为 leader；
   2. 另一个节点赢得此次选举，成为 leader；
   3. 选举超时，没有产生有效 leader。

## 实现记录

### Lab 3A

首先照着论文的figure2 state部分把能定义的定义了。要用到的包括currentTerm，votedFor和定义当前server是什么状态

然后我们先来实现make函数，对server启动的初始化

* 注释说明，对于任何耗时长的操作应该启用go routine来异步启动

### 几个问题

* 计时器重置问题：当server收到心跳时/当server收到requestVote时。当收到rpc的时候需要考虑重置定时器。论文似乎没有提到这一点。
  * 你可能可以参考这个[链接](https://www.cnblogs.com/way2backend/p/17294484.html)
* go select特性：如果有一个可用，走那个case；如果有多个可以用，随机选一个case；如果都不可用，走default（非阻塞）或者阻塞等待读